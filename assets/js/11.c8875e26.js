(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{289:function(t,s,a){"use strict";a.r(s);var n=a(13),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p"),s("div",{staticClass:"table-of-contents"},[s("ul")]),s("p"),t._v(" "),s("h2",{attrs:{id:"异常"}},[t._v("异常")]),t._v(" "),s("img",{staticStyle:{zoom:"25%"},attrs:{src:"img/Throwable.jpg",alt:"JDK类加载器和tomcat自定义类加载器",align:"left"}}),t._v(" "),s("p",[t._v("Throwable是java语言中所有错误和异常的超类。它有两个子类：Error、Exception。")]),t._v(" "),s("p",[s("code",[t._v("Error(错误)")]),t._v("：Error类及其子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。程序员应该关注Exception为父类的分支下的各种异常类。\n"),s("code",[t._v("Exception(异常)")]),t._v("：Exception及其子类，代表程序运行时的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。")]),t._v(" "),s("p",[t._v("异常又通常被分为两类："),s("code",[t._v("非检查异常(Unchecked Exception)")]),t._v("、"),s("code",[t._v("检查异常(Checked Exception)")])]),t._v(" "),s("p",[s("code",[t._v("Unchecked Exception")]),t._v("：编译时不会提示和发生异常，运行时一般会报错，例如："),s("code",[t._v("NullPointerException")]),t._v("、"),s("code",[t._v("ArithmeticException")]),t._v("、"),s("code",[t._v("IndexOutOfBoundsException")]),t._v("等")]),t._v(" "),s("p",[s("code",[t._v("Checked Exception")]),t._v("：编译时就会提示异常，程序要求强制通过try...catch或者throws处理否则编译不通过，例如："),s("code",[t._v("IOException")]),t._v("、"),s("code",[t._v("SQLException")]),t._v("、"),s("code",[t._v("ClassNotFoundExceptioon")]),t._v("等")]),t._v(" "),s("h2",{attrs:{id:"集合"}},[t._v("集合")]),t._v(" "),s("h3",{attrs:{id:"集合分类"}},[t._v("集合分类")]),t._v(" "),s("ol",[s("li",[t._v("线程不安全的集合"),s("code",[t._v("ArrayList")]),t._v("、"),s("code",[t._v("LinkedList")]),t._v("、"),s("code",[t._v("HashMap")]),t._v("、"),s("code",[t._v("TreeMap")]),t._v("、"),s("code",[t._v("HashSet")]),t._v("、"),s("code",[t._v("TreeSet")]),t._v("。"),s("code",[t._v("HashSet")]),t._v(": 基于HashMap实现，值作为HashMap的key存储的所以是不重复、无序的")]),t._v(" "),s("li",[t._v("线程安全的集合: "),s("code",[t._v("HashTable")]),t._v("、"),s("code",[t._v("Vector")])]),t._v(" "),s("li",[t._v("高性能的线程安全集合\n"),s("code",[t._v("ConcurrentHashMap")]),t._v(": jdk1.7基于分段锁实现，将数组分割多段，每段添加一个锁，所线程访问不同数据段的数据就不会出现锁竞争。jdk1.8采用CAS+Synchronize来保证线程安全，Synchronized只锁链表和红黑树的首节点，只要hash不冲突就不会产生并发，从而提升效率\n"),s("code",[t._v("ConcurrentSkipListMap")]),t._v(": 基于链表实现，线程安全的有序的map，相当于线程安全的TreeMap\n"),s("code",[t._v("ConcurrentSkipListSet")]),t._v(": 线程安全的有序集合，相当于线程安全的TreeSet\n"),s("code",[t._v("CopyOnWriteArrayList")]),t._v(": 线程安全的List，读写分离的思想，写数据前先copy一份（加锁），然后再新增，此时读还是基于原有的数组，新增完之后再移动指针，适用于读多写少，实时性要求不高的场景\n"),s("code",[t._v("CopyOnWriteArraySet")]),t._v(": 基于CopyOnWriteArrayList实现")])]),t._v(" "),s("h3",{attrs:{id:"hashmap"}},[t._v("HashMap")]),t._v(" "),s("p",[t._v("HashMap用来存储键值对类型的数据，基于哈希表来存储，在JDK1.8中的就是一个Node[]")]),t._v(" "),s("p",[s("strong",[t._v("存储数据")])]),t._v(" "),s("p",[s("code",[t._v('map.put("key","value")')])]),t._v(" "),s("ol",[s("li",[t._v("根据key的hashCode方法得到hashCode值")]),t._v(" "),s("li",[t._v("根据Hash算法的后两部运算（高位运算和取模运算）确定键值对的存储在数组的位置")]),t._v(" "),s("li",[t._v("如果同时存在两个key计算得到相同的位置，说明hash冲突了")])]),t._v(" "),s("p",[s("strong",[t._v("哈希表解决Hash冲突的方法")])]),t._v(" "),s("ol",[s("li",[t._v("开放地址发")])]),t._v(" "),s("ul",[s("li",[t._v("线性探测法：遇到冲突，判断下一位是否为空")]),t._v(" "),s("li",[t._v("平方探查法：遇到冲突，查找当前索引平方后位置是否为空")]),t._v(" "),s("li",[t._v("双哈希法：有多个hash函数，当发生冲突时，使用第二个，第三个，直到无冲突")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("链地址法：采用链表的结构，每个hash表的节点都有一个next指针，发生冲突时，插入到这个单向链表")])]),t._v(" "),s("blockquote",[s("p",[t._v("hash算法计算的结果越分散，hash碰撞概率越小，map存取效率越高\nhash表数组越大，即hash桶数组越大，计算结果也会越分散，hash碰撞概率也会越小\n通过扩容机制+Hash算法，即可满足节省内存也可以尽量减少hash碰撞的概率")])]),t._v(" "),s("p",[t._v("HashMap默认长度16，默认负载因子(Load Factor)0.75，threadHold = length * LoadFactor，当hash桶的使用率超过这个个数时需要扩容为原来两倍")]),t._v(" "),s("blockquote",[s("p",[t._v("hash桶的大小设置成2^n是为了在取模和扩容时做优化，同时为了减少冲突（HashMap定位哈希桶索引位置的时候也加入了高位参与运算）")])]),t._v(" "),s("p",[s("strong",[t._v("JDK1.8与JDK1.7的对比")])]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("数据结构")]),t._v("：1.7是"),s("code",[t._v("数组+单链表")]),t._v("，1.8变成"),s("code",[t._v("数组+单链表+红黑树")]),t._v("，当链表长度增加时，插入和查询的效率都会降低，链表长度超过8时转换成红黑树，小于6时退化成链表，引入红黑树可以提高查询效率，红黑树一种特殊的平衡二叉树，通过着色、自旋等特性能使得查询、插入和删除时间复杂度控制在O(log N)")]),t._v(" "),s("li",[s("strong",[t._v("扩容优化")]),t._v("：1.7扩容后需要重新计算每个桶的位置，1.8之后无需重新计算新的位置，要么不变，要么变成原位置+oldCap，扩容之所变成原来两倍")]),t._v(" "),s("li",[s("strong",[t._v("链表节点的插入方式")]),t._v("：之前是头插法，1.8后变成了尾插法，因为在并发操作下，头插法会出现环形链表的情况，但这并不是说1.8之后hashmap就是线程安全的，只是针对1.7做了优化，并发情况下还会出现其他的问题，例如数据覆盖")]),t._v(" "),s("li",[s("strong",[t._v("hash函数的优化")]),t._v("：Java1.8的hash()中，将hash值高位（前16位）参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率")])]),t._v(" "),s("h3",{attrs:{id:"concurrenthashmap"}},[t._v("ConcurrentHashMap")]),t._v(" "),s("p",[t._v("HashTable是线程安全的Map，不允许null键值对，安全的机制是对put等方法添加synchronized关键字，相当于对整个对象加锁，锁住了整个hash表，所以效率低下，已经被废弃。取而代之的是ConcurrentHashMap。")]),t._v(" "),s("p",[t._v("JDK1.7中ConcurrentHashMap采用分段锁的机制保证线程安全。具体来说，将Hash表分为多个分段Segment，每个Segment通过继承ReentrantLock来加锁，这样就保证了每个Segment的线程安全同时也提高的并发的性能。")]),t._v(" "),s("p",[t._v("JDK1.8中ConcurrentHashMap采用与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现")]),t._v(" "),s("h3",{attrs:{id:"treemap"}},[t._v("TreeMap")]),t._v(" "),s("p",[t._v("有序的Map，基于红黑树实现，实现了"),s("code",[t._v("NavigableMap")]),t._v("->"),s("code",[t._v("SortedMap")])]),t._v(" "),s("h2",{attrs:{id:"synchronized"}},[t._v("Synchronized")]),t._v(" "),s("p",[t._v("synchronized是基于JVM实现的，非公平的、可重入的重量级锁")]),t._v(" "),s("p",[s("strong",[t._v("基本使用")])]),t._v(" "),s("ol",[s("li",[t._v("修饰普通方法、修饰代码块指定this，对象锁，表示锁住当前对象（this），也可以自己指定锁住对象")]),t._v(" "),s("li",[t._v("修饰静态方法、修饰代码块指定class，类锁，表示锁住整个类，同时只能有一个线程访问该类")])]),t._v(" "),s("p",[s("strong",[t._v("加锁和释放锁的原理")])]),t._v(" "),s("p",[t._v("底层是通过指令"),s("code",[t._v("monitorenter")]),t._v("和"),s("code",[t._v("monitorexit")]),t._v("以及"),s("code",[t._v("monitor计数器")]),t._v("实现。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得。")]),t._v(" "),s("ul",[s("li",[t._v("当执行"),s("code",[t._v("monitorenter")]),t._v("加锁指令时：\n"),s("ul",[s("li",[t._v("如果"),s("code",[t._v("monitor计数器")]),t._v("为0，则表示尚未获取，则该线程会立刻获取到锁，并且将锁计数器+1")]),t._v(" "),s("li",[t._v("如果当前对象已经持有了该锁，又重入了该锁，则将锁计数器+1")]),t._v(" "),s("li",[t._v("如果该锁被其他线程持有，则阻塞等待锁被释放")])])]),t._v(" "),s("li",[t._v("当执行"),s("code",[t._v("monitorexit")]),t._v("释放锁指令时：将锁计数器-1，如果减完不为0表示刚才是重入的，仍然持有该锁；如果减完为0，表示不再持有该锁")])]),t._v(" "),s("blockquote",[s("p",[t._v("synchronized先天具有重入性。就是基于锁计数器实现的，每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一")])]),t._v(" "),s("p",[s("strong",[t._v("Synchronized优化")])]),t._v(" "),s("p",[t._v("JDK1.6之前，synchronized性能表现不佳，JDK1.6对其进行了一些列的优化，锁粗化、锁消除、以及引入偏向锁、轻量级锁、适应性自旋锁等减少锁的开销，优化的核心理念是："),s("strong",[t._v("根据当前的并发度尽可能的避免直接用OS(操作系统)的互斥量（Mutex Lock）完成同步操作")])]),t._v(" "),s("p",[s("strong",[t._v("锁粗化")])]),t._v(" "),s("p",[t._v("如果发现有代码⾥连续多次加锁释放锁的代码，会给合并为⼀个锁，就是锁粗化，避免频繁多次加锁释放锁")]),t._v(" "),s("p",[s("strong",[t._v("锁消除")])]),t._v(" "),s("p",[t._v("在编译的时候，JIT编译器会通过逃逸分析技术，来分析synchronized锁对象，是不是只可能被⼀个线程来加锁，没有其他的线程来竞争加锁，这个时候编译就不⽤加⼊monitorenter和monitorexit的指令\n就可以消除这个锁了，提升这段代码的执⾏的效率，例如在方法里面对一段代码加对象锁，但代码里的常量不会直接返回，也就不会出现逃逸，线程绝对安全，也就不需要加锁。")]),t._v(" "),s("p",[t._v("JDK1.6，synchronized同步锁有四种状态："),s("code",[t._v("无锁")]),t._v("、"),s("code",[t._v("偏向锁")]),t._v("、"),s("code",[t._v("轻量级锁")]),t._v("、"),s("code",[t._v("重量级锁")]),t._v("，会随着竞争情况（并发度）逐渐升级。锁可以升级但是不可以降级。")]),t._v(" "),s("blockquote",[s("p",[t._v("无锁 → 偏向锁 → 轻量级锁 → 重量级锁")])]),t._v(" "),s("p",[s("strong",[t._v("无锁")])]),t._v(" "),s("p",[t._v("不锁住资源，多个线程中只有一个能修改成功，其他线程会重试直到修改成功。CAS就是无锁的一种实现")]),t._v(" "),s("p",[s("strong",[t._v("偏向锁")])]),t._v(" "),s("p",[t._v("偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价")]),t._v(" "),s("p",[t._v("当一个线程访问同步代码块并获取锁时，会在Mark Word（基于Hotspot虚拟机）里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。")]),t._v(" "),s("p",[t._v("偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁")]),t._v(" "),s("p",[t._v("JDK 6及之后版本中是默认启用的。可通过JVM参数关闭："),s("code",[t._v("-XX:UseBiasedLocking=false")]),t._v("，关闭之后程序默认会进入轻量级锁状态")]),t._v(" "),s("p",[s("strong",[t._v("轻量级锁")])]),t._v(" "),s("p",[t._v("当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。")]),t._v(" "),s("p",[s("strong",[t._v("重量级锁")])]),t._v(" "),s("p",[t._v("当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。")]),t._v(" "),s("blockquote",[s("p",[t._v("综上，"),s("code",[t._v("偏向锁")]),t._v("通过对比Mark Word解决加锁问题，避免执行CAS操作。而"),s("code",[t._v("轻量级锁")]),t._v("是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。"),s("code",[t._v("重量级锁")]),t._v("是将除了拥有锁的线程以外的线程都阻塞。")])]),t._v(" "),s("h2",{attrs:{id:"volatile"}},[t._v("volatile")]),t._v(" "),s("p",[s("strong",[t._v("防止指令重排序")])]),t._v(" "),s("p",[t._v("案例：双重校验锁的单例模式，实例化对象分为三步："),s("code",[t._v("分配内存空间")]),t._v("、"),s("code",[t._v("初始化对象")]),t._v("、"),s("code",[t._v("将内存空间地址复制给对应的引用")]),t._v("，由于存在指令重排的存在，可能发生分配内存空间之后，就将地址复制给引用了，导致返回的对象尚未初始化完成。")]),t._v(" "),s("p",[s("strong",[t._v("实现可见性")])]),t._v(" "),s("p",[t._v("基于Java内存模型，每个线程中拥有一个缓存区（线程工作内存），一个线程加载了物理内存中的共享变量到缓存区进行了更改，另一个线程是看不到的，如果其他线程同样做这样的操作，然后两个线程先后刷新更改到物理内存中，就会出现一个线程的更新丢失的情况，volatile就是解决这个问题的")]),t._v(" "),s("h2",{attrs:{id:"threadlocal"}},[t._v("ThreadLocal")]),t._v(" "),s("p",[s("code",[t._v("ThreadLocal")]),t._v("是一个在多线程中为每一个线程创建单独的变量副本的类，避免多线程操作共享变量导致数据不一致的情况。")]),t._v(" "),s("p",[s("strong",[t._v("基本原理")])]),t._v(" "),s("div",{staticClass:"language-Java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ThreadLocal set方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadLocalMap")]),t._v(" map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ThreadLocal get方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadLocalMap")]),t._v(" map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("map "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadLocalMap"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Entry")]),t._v(" e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getEntry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@SuppressWarnings")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"unchecked"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInitialValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br")])]),s("p",[t._v("每个Thread都会有一个"),s("code",[t._v("ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue)")]),t._v("的引用，用来存储当前线程周期内所需要存储的数据，其他线程无法获取，在当前线程中，我们创建ThreadLocal并来存储数据时，会先判断当前线程中是否有一个这样全局唯一的ThreadLocalMap，不存在则创建，存在则直接存储数据，key为我们创建的ThreadLocal，value是需要存储的值。同一个线程中可以有多个ThreadLocal。所以用Map存储，每个ThreadLocal对象都是唯一的，都有一个唯一标识的threadLocalHashCode，这个hashCode是一个static的AtomicInteger类型，每次加一也是原子性的，所以保证了ThreadLocal对象的唯一性，所以用ThreadLocal作为Map的key。ThreadLocal只是作为一个访问线程内部的ThreadLocalMap的入口。")]),t._v(" "),s("p",[s("strong",[t._v("ThreadLocal内存泄漏问题")])]),t._v(" "),s("p",[t._v("ThreadLocalMap的key是一个弱引用，这意味着，如果我们使用ThradLocal对象时，没有了强引用，则GC就会回收该对象，就导致了ThreadLocalMap内Entry的key就变成null，但是enrty本身还是有一个强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value，如果线程迟迟没有死亡，那么永远无法回收，造成内存泄漏。")]),t._v(" "),s("p",[t._v("所以官方推荐将ThreadLocal定义为static全局唯一，避免丢失ThreadLocal强引用，就能保证随时remove掉entry内的key与value。")]),t._v(" "),s("p",[s("code",[t._v("InheritableThreadLocal")]),t._v("可以实现父子线程间数据传递")]),t._v(" "),s("p",[s("code",[t._v("TransmittableThreadLocal")]),t._v("跨线程池的场景下，线程间数据的传递")]),t._v(" "),s("h2",{attrs:{id:"juc"}},[t._v("JUC")]),t._v(" "),s("h3",{attrs:{id:"锁"}},[t._v("锁")]),t._v(" "),s("p",[t._v("JUC中的锁包含三个重要的实现：ReentrantLock、ReentrantReadWriteLock、StampedLock")]),t._v(" "),s("p",[s("strong",[t._v("AQS")]),t._v("：队列同步器，是构建锁及其他同步组件的基础，AQS使用一个int类型的成员变量state来表示同步状态，当state>0时表示已经获取了锁，当state = 0时表示释放了锁。AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// AQS提供的获取独占式锁的模板方法，该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// tryAcquire 尝试获取锁，成功为true，失败为false")]),t._v("\n\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果失败，则调用addWaiter加入CLH同步队列尾部")]),t._v("\n\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// acquireQueued：当前线程会进行自选阻塞等待,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过，如果有，则自我中断，否则结束方法调用")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EXCLUSIVE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 整个过程是否失败的标识，便于finally执行取消获取锁")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" failed "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        \t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 中断标识")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" interrupted "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 自旋尝试获取锁，直到成功为止")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("predecessor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" head "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHead")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// help GC")]),t._v("\n                    failed "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" interrupted"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// shouldParkAfterFailedAcquire 检查并更新获取锁失败的节点的状态。如果线程应该阻塞（锁已经被其他线程占用时，当前线程应该被阻塞），则返回true。")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// parkAndCheckInterrupt 通过LockSupport.park 阻塞当前线程，并返回当前线程是否被中断过，决定后续是否自我中断")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldParkAfterFailedAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parkAndCheckInterrupt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                    interrupted "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("failed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cancelAcquire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br")])]),s("p",[s("strong",[t._v("CLH同步队列")]),t._v("\nAQS中维护的FIFO双向队列就是CLH同步队列，在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next）")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//CLH入队方法，双向链表入队，设置前驱节点和，前驱节点和后置节点即可")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 基于当前线程的基本信息，构建一个Node")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" pred "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过一次CAS操作，尝试快速加入双向链表尾部")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetTail")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                pred"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 成功就返回")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 否则，enq方法中进行循环CAS尝试加入链表尾部")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("enq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br")])]),s("p",[s("strong",[t._v("StampedLock")])]),t._v(" "),s("p",[t._v("StampedLock和ReadWriteLock相比，改进之处在于：提供了乐观读锁的相关方法， 读的过程中也允许获取写锁后写入，如果获取乐观读锁后，发现有写锁获取过，则怀疑数据已经被窜改，会升级成悲观读锁.")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//乐观读锁案例")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("distanceFromOrigin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//sl(StampedLock)获得一个乐观读锁")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" stamp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryOptimisticRead")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" currentX "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" currentY "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将两个字段读入本地局部变量")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("sl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("validate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stamp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//检查发出乐观读锁后同时是否有其他写锁发生？")]),t._v("\n                stamp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("readLock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 验证失败，有写锁发生，获得一个悲观读锁")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    currentX "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 重新读入本地局部变量")]),t._v("\n                    currentY "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    sl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlockRead")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("stamp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 释放悲观读锁")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sqrt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("currentX "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" currentX "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" currentY "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" currentY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("h3",{attrs:{id:"atomic"}},[t._v("Atomic")]),t._v(" "),s("p",[t._v("底层是基于Unsafe类的本地方法"),s("code",[t._v("compareAndSwapInt")]),t._v("实现的，意思是比较后交换，如果当前值==预期值，原子化地将该值设置为给定的更新值。")]),t._v(" "),s("h3",{attrs:{id:"blockingqueue"}},[t._v("BlockingQueue")]),t._v(" "),s("ul",[s("li",[t._v("ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。")]),t._v(" "),s("li",[t._v("LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。")]),t._v(" "),s("li",[t._v("PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。")]),t._v(" "),s("li",[t._v("DelayQueue：一个使用优先级队列实现的无界阻塞队列。")]),t._v(" "),s("li",[t._v("SynchronousQueue：一个不存储元素的阻塞队列。")]),t._v(" "),s("li",[t._v("LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。")]),t._v(" "),s("li",[t._v("LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。")])]),t._v(" "),s("h3",{attrs:{id:"线程池"}},[t._v("线程池")]),t._v(" "),s("h4",{attrs:{id:"线程状态"}},[t._v("线程状态")]),t._v(" "),s("ul",[s("li",[t._v("NEW：创建一个线程，还没有调用start方法")]),t._v(" "),s("li",[t._v("RUNNABLE：调用对了线程的start方法，进入ready（就绪）状态，等待别线程调度选中，获取CPU使用权，当获取CPU使用权后编程running（运行中）")]),t._v(" "),s("li",[t._v("BLOCKED：线程在获取资源锁时被阻塞")]),t._v(" "),s("li",[t._v("WAITING：该状态的线程，需要等待其他线程唤醒或中断")]),t._v(" "),s("li",[t._v("TIME_WAITING：指定时间后自行返回")]),t._v(" "),s("li",[t._v("TERMINATED：线程终止")])]),t._v(" "),s("p",[s("img",{attrs:{src:"img/thread-status.jpg",alt:"线程状态"}})]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Thread.sleep(millis)")]),t._v("不会释放当前线程占有的锁，无法从外部唤醒、只能超时自动恢复")]),t._v(" "),s("li",[s("code",[t._v("Thread.join()/Thread.join(millis)")]),t._v("当前线程调用其他线程t的join方法，进入WAITING/TIMED_WAITING状态，当前线程不会释放已持有的对象锁，其他线程执行结束或者"),s("code",[t._v("millis")]),t._v("时间到，进入RUNNABLE状态，也有可能进入BLOCKED状态，因为join基于wait实现")]),t._v(" "),s("li",[s("code",[t._v("Thread.yield()")]),t._v("当前线程调用此方法，放弃CPU时间片，但不释放所资源，实际中无法保证使用此方法做到线程让步，因为可能存在被CPU的线程调度再次选中")]),t._v(" "),s("li",[s("code",[t._v("Object.wait()/Object.wait(millis)")]),t._v("会释放当前线程占有的对象锁，使当前线程进入等待队列，调用"),s("code",[t._v("Object.notify()/notifyAll()")]),t._v("或者到时间了会被唤醒，如果能立刻获取到锁，则继续执行，否则进入同步队列（blocked）等待获取锁资源")]),t._v(" "),s("li",[s("code",[t._v("LockSupport.park()/LockSupport.parkNanos()/LockSupport.parkUntil")]),t._v("只负责阻塞当前线程，不释放当前线程占有的锁资源，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容")])]),t._v(" "),s("h4",{attrs:{id:"线程池的使用场景"}},[t._v("线程池的使用场景")]),t._v(" "),s("ol",[s("li",[t._v("异步任务配置线程池，不同类型的异步任务线程池参数不同")]),t._v(" "),s("li",[t._v("并发获取、处理数据，例如获取整个A股市场所有股票的行情数据，可以使用CompletionService来并发获取，然后最后合并结果集处理。这里面就需要配置线程池")])]),t._v(" "),s("p",[t._v("类似这种需要并发处理一个大任务的场景都需要用到线程池。")]),t._v(" "),s("h4",{attrs:{id:"线程池的核心参数"}},[t._v("线程池的核心参数")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" availableProcessors "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runtime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRuntime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("availableProcessors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadPoolExecutor")]),t._v(" executorService "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ThreadPoolExecutor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("availableProcessors "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("40")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TimeUnit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SECONDS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LinkedBlockingQueue")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("线程池的核心参数：")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("corePoolSize")]),t._v(": 核心线程数，保留在线程池中的线程数，即使是空闲状态。除非设置了"),s("code",[t._v("allowCoreThreadTimeOut")])]),t._v(" "),s("li",[s("code",[t._v("maximumPoolSize")]),t._v(": 最大线程数，线程池中允许存在的最大线程数量")]),t._v(" "),s("li",[s("code",[t._v("keepAliveTime")]),t._v(": 当线程池中的线程数大于"),s("code",[t._v("corePoolSize")]),t._v("时，多余的空闲线程等待任务的最大超时时间")]),t._v(" "),s("li",[s("code",[t._v("unit")]),t._v(": "),s("code",[t._v("keepAliveTime")]),t._v("参数的单位")]),t._v(" "),s("li",[s("code",[t._v("workQueue")]),t._v(": 队列，存储尚未执行的任务")]),t._v(" "),s("li",[s("code",[t._v("ThreadFactory")]),t._v(": 线程工厂，用于创建线程")]),t._v(" "),s("li",[s("code",[t._v("RejectedExecutionHandler")]),t._v(": 拒绝策略，当线程数量和任务队列达到边界条件被阻塞时的拒绝策略")])]),t._v(" "),s("p",[s("strong",[t._v("线程池拒绝策略")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("AbortPolicy ，默认的拒绝策略，抛出一个异常")]),t._v(" "),s("li",[t._v("CallerRunsPolicy，如果线程池没有关闭，就由提交任务的当前线程处理。")]),t._v(" "),s("li",[t._v("DiscardPolicy，丢弃策略")]),t._v(" "),s("li",[t._v("DiscardOldestPolicy，丢弃最老任务，如果线程池未关闭，就弹出队列头部的元素")])]),t._v(" "),s("h4",{attrs:{id:"线程池的工作流程"}},[t._v("线程池的工作流程")]),t._v(" "),s("ol",[s("li",[t._v("当线程数n小于corePoolSize时，创建新的线程执行任务")]),t._v(" "),s("li",[t._v("当线程数n大于corePoolSize且小于maximumPoolSize时：\n"),s("ul",[s("li",[t._v("如果任务队列没满，则任务添加到队列中，等待执行")]),t._v(" "),s("li",[t._v("如果任务队列满，则创建线程执行任务")])])]),t._v(" "),s("li",[t._v("如果线程数n等于maximumPoolSize时，再有任务到达时，执行拒绝策略")])]),t._v(" "),s("h4",{attrs:{id:"线程池参数的配置"}},[t._v("线程池参数的配置")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("经验之谈")])]),t._v("：如果一个机器有N个CPU或者只有一个CPU但是有N个核心，对于执行的任务，如果属于计算密集型任务，则应设置核心线程数为N+1；如果是IO密集型任务，则应设置核心线程数为N*2；对于同时具有计算和IO工作的任务，应考虑使用两个线程池，一个处理了计算任务，一个处理IO任务")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("两种计算公式")])])]),t._v(" "),s("p",[t._v("《Java并发编程实践》中线程池的核心线程数计算公式 "),s("code",[t._v("Nthreads = Ncpu x Ucpu x (1 + W/C)")])]),t._v(" "),s("ul",[s("li",[t._v("Ncpu：CPU数量或核心数")]),t._v(" "),s("li",[t._v("Ucpu：目标CPU的使用率，[0,1)")]),t._v(" "),s("li",[t._v("W/C：等待时间/计算时间 的比率")])]),t._v(" "),s("p",[t._v("《Java虚拟机并发编程》中的线程数计算公式"),s("code",[t._v("Nthreads = Ncpu*(1-阻塞系数)")])]),t._v(" "),s("ul",[s("li",[t._v("Ncpu：CPU数量或核心数")]),t._v(" "),s("li",[t._v("阻塞系数："),s("code",[t._v("阻塞系数=阻塞时间/(阻塞时间+计算时间)")]),t._v("[0,1)。计算密集型任务的阻塞系数为0，而IO密集型任务的阻塞系数则接近1，一个完全阻塞的任务是注定要挂掉的，所以我们无须担心阻塞系数会达到1。")])]),t._v(" "),s("p",[t._v("对于计算密集型任务，假设等待实践趋近0，CPU利用率达到100%，对于公式1，线程数=Ncpu")]),t._v(" "),s("blockquote",[s("p",[t._v("计算密集型的线程恰好在某时因为发生一个错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作\n所以，计算型密集型任务的核心线程数为 N+1")])]),t._v(" "),s("p",[t._v("对于IO密集型应用，假定所有的操作时间几乎都是IO操作耗时，那么W/C的值就为1，基于公式1，线程数=2N")]),t._v(" "),s("h2",{attrs:{id:"forkjoin"}},[t._v("ForkJoin")]),t._v(" "),s("p",[s("code",[t._v("ForkJoin")]),t._v("是一个用于并行执行任务的框架，是一个把大任务划分成若干个小任务，最后汇总小任务执行结果得到大任务执行结果的框架。")]),t._v(" "),s("h3",{attrs:{id:"使用场景"}},[t._v("使用场景")]),t._v(" "),s("p",[t._v("适合能够进行拆分计算和合并结果的任务。要求服务器拥有多CPU、多核，用以提高计算能力。")]),t._v(" "),s("p",[s("strong",[t._v("原理")])]),t._v(" "),s("ol",[s("li",[t._v("任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割")]),t._v(" "),s("li",[t._v("执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。")])]),t._v(" "),s("h3",{attrs:{id:"工作窃取算法"}},[t._v("工作窃取算法")]),t._v(" "),s("p",[t._v("将一个大任务分割成若干个相互独立的子任务，将子任务放到不同的队列中，为每个队列分配线程依次执行队列中的任务，队列和线程一一对应，如果A线程执行完了绑定队列中的任务，而B线程对应队列的任务还没执行完，此时如果为了充分利用资源，线程A会在线程B对应的双端队列的尾部窃取一个任务之行，线程B总是从双端队列的头部取任务。优点：充分利用资源、并行执行计算任务，减少线程间的冲突。缺点：存在任务争夺问题")]),t._v(" "),s("h2",{attrs:{id:"参考文献"}},[t._v("参考文献")]),t._v(" "),s("ul",[s("li",[t._v("美团技术-HashMap："),s("a",{attrs:{href:"https://tech.meituan.com/2016/06/24/java-hashmap.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://tech.meituan.com/2016/06/24/java-hashmap.html"),s("OutboundLink")],1)]),t._v(" "),s("li",[t._v("美团技术-Java的锁：https://tech.meituan.com/2018/11/15/java-lock.html")])])])}),[],!1,null,null,null);s.default=e.exports}}]);