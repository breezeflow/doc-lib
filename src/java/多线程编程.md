[[TOC]]
## 线程池

### 线程状态

- NEW：创建一个线程，还没有调用start方法
- RUNNABLE：调用对了线程的start方法，进入ready（就绪）状态，等待别线程调度选中，获取CPU使用权，当获取CPU使用权后编程running（运行中）
- BLOCKED：线程在获取资源锁时被阻塞
- WAITING：该状态的线程，需要等待其他线程唤醒或中断
- TIME_WAITING：指定时间后自行返回
- TERMINATED：线程终止

![线程状态](~@img/java/thread-status.jpg)

- `Thread.sleep(millis)`不会释放当前线程占有的锁，无法从外部唤醒、只能超时自动恢复
- `Thread.join()/Thread.join(millis)`当前线程调用其他线程t的join方法，进入WAITING/TIMED_WAITING状态，当前线程不会释放已持有的对象锁，其他线程执行结束或者`millis`时间到，进入RUNNABLE状态，也有可能进入BLOCKED状态，因为join基于wait实现
- `Thread.yield()`当前线程调用此方法，放弃CPU时间片，但不释放所资源，实际中无法保证使用此方法做到线程让步，因为可能存在被CPU的线程调度再次选中
- `Object.wait()/Object.wait(millis)`会释放当前线程占有的对象锁，使当前线程进入等待队列，调用`Object.notify()/notifyAll()`或者到时间了会被唤醒，如果能立刻获取到锁，则继续执行，否则进入同步队列（blocked）等待获取锁资源
- `LockSupport.park()/LockSupport.parkNanos()/LockSupport.parkUntil`只负责阻塞当前线程，不释放当前线程占有的锁资源，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容

### 线程池的使用场景

1. 异步任务配置线程池，不同类型的异步任务线程池参数不同
2. 并发获取、处理数据，例如获取整个A股市场所有股票的行情数据，可以使用CompletionService来并发获取，然后最后合并结果集处理。这里面就需要配置线程池

类似这种需要并发处理一个大任务的场景都需要用到线程池。

###  线程池的核心参数

```java
int availableProcessors = Runtime.getRuntime().availableProcessors();
ThreadPoolExecutor executorService = new ThreadPoolExecutor(availableProcessors * 2,40,10, TimeUnit.SECONDS, new LinkedBlockingQueue<>(5000));
```

线程池的核心参数：
1. `corePoolSize`: 核心线程数，保留在线程池中的线程数，即使是空闲状态。除非设置了`allowCoreThreadTimeOut`
2. `maximumPoolSize`: 最大线程数，线程池中允许存在的最大线程数量
3. `keepAliveTime`: 当线程池中的线程数大于`corePoolSize`时，多余的空闲线程等待任务的最大超时时间
4. `unit`: `keepAliveTime`参数的单位
5. `workQueue`: 队列，存储尚未执行的任务
6. `ThreadFactory`: 线程工厂，用于创建线程
7. `RejectedExecutionHandler`: 拒绝策略，当线程数量和任务队列达到边界条件被阻塞时的拒绝策略

**线程池拒绝策略**：
- AbortPolicy ，默认的拒绝策略，抛出一个异常
- CallerRunsPolicy，如果线程池没有关闭，就由提交任务的当前线程处理。
- DiscardPolicy，丢弃策略
- DiscardOldestPolicy，丢弃最老任务，如果线程池未关闭，就弹出队列头部的元素

### 线程池的工作流程
1. 当线程数n小于corePoolSize时，创建新的线程执行任务
2. 当线程数n大于corePoolSize且小于maximumPoolSize时：
    - 如果任务队列没满，则任务添加到队列中，等待执行
    - 如果任务队列满，则创建线程执行任务
3. 如果线程数n等于maximumPoolSize时，再有任务到达时，执行拒绝策略

### 线程池参数的配置

***经验之谈***：如果一个机器有N个CPU或者只有一个CPU但是有N个核心，对于执行的任务，如果属于计算密集型任务，则应设置核心线程数为N+1；如果是IO密集型任务，则应设置核心线程数为N*2；对于同时具有计算和IO工作的任务，应考虑使用两个线程池，一个处理了计算任务，一个处理IO任务

***两种计算公式***

《Java并发编程实践》中线程池的核心线程数计算公式 `Nthreads = Ncpu x Ucpu x (1 + W/C)`
- Ncpu：CPU数量或核心数
- Ucpu：目标CPU的使用率，[0,1)
- W/C：等待时间/计算时间 的比率

《Java虚拟机并发编程》中的线程数计算公式`Nthreads = Ncpu*(1-阻塞系数)`
- Ncpu：CPU数量或核心数
- 阻塞系数：`阻塞系数=阻塞时间/(阻塞时间+计算时间)`[0,1)。计算密集型任务的阻塞系数为0，而IO密集型任务的阻塞系数则接近1，一个完全阻塞的任务是注定要挂掉的，所以我们无须担心阻塞系数会达到1。

对于计算密集型任务，假设等待实践趋近0，CPU利用率达到100%，对于公式1，线程数=Ncpu
>计算密集型的线程恰好在某时因为发生一个错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作
所以，计算型密集型任务的核心线程数为 N+1

对于IO密集型应用，假定所有的操作时间几乎都是IO操作耗时，那么W/C的值就为1，基于公式1，线程数=2N