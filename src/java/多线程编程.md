[[TOC]]

## 线程池

### 线程状态

- NEW：创建一个线程，还没有调用start方法
- RUNNABLE：调用对了线程的start方法，进入ready（就绪）状态，等待别线程调度选中，获取CPU使用权，当获取CPU使用权后编程running（运行中）
- BLOCKED：线程在获取资源锁时被阻塞
- WAITING：该状态的线程，需要等待其他线程唤醒或中断
- TIME_WAITING：指定时间后自行返回
- TERMINATED：线程终止

![线程状态](~@img/java/thread-status.jpg)

- `Thread.sleep(millis)`不会释放当前线程占有的锁，无法从外部唤醒、只能超时自动恢复
- `Thread.join()/Thread.join(millis)`
  当前线程调用其他线程t的join方法，进入WAITING/TIMED_WAITING状态，当前线程不会释放已持有的对象锁，其他线程执行结束或者`millis`
  时间到，进入RUNNABLE状态，也有可能进入BLOCKED状态，因为join基于wait实现
- `Thread.yield()`当前线程调用此方法，放弃CPU时间片，但不释放所资源，实际中无法保证使用此方法做到线程让步，因为可能存在被CPU的线程调度再次选中
- `Object.wait()/Object.wait(millis)`会释放当前线程占有的对象锁，使当前线程进入等待队列，调用`Object.notify()/notifyAll()`
  或者到时间了会被唤醒，如果能立刻获取到锁，则继续执行，否则进入同步队列（blocked）等待获取锁资源
- `LockSupport.park()/LockSupport.parkNanos()/LockSupport.parkUntil`
  只负责阻塞当前线程，不释放当前线程占有的锁资源，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容

### 线程池的核心参数

```java
int availableProcessors = Runtime.getRuntime().availableProcessors();
ThreadPoolExecutor executorService = new ThreadPoolExecutor(availableProcessors * 2,40,10, TimeUnit.SECONDS, new LinkedBlockingQueue<>(5000));
```

线程池的核心参数：

1. `corePoolSize`: 核心线程数，保留在线程池中的线程数，即使是空闲状态。除非设置了`allowCoreThreadTimeOut`
2. `maximumPoolSize`: 最大线程数，线程池中允许存在的最大线程数量
3. `keepAliveTime`: 当线程池中的线程数大于`corePoolSize`时，多余的空闲线程等待任务的最大超时时间
4. `unit`: `keepAliveTime`参数的单位
5. `workQueue`: 队列，存储尚未执行的任务
6. `ThreadFactory`: 线程工厂，用于创建线程
7. `RejectedExecutionHandler`: 拒绝策略，当线程数量和任务队列达到边界条件被阻塞时的拒绝策略

**线程池拒绝策略**：

- AbortPolicy ，默认的拒绝策略，抛出一个异常
- CallerRunsPolicy，如果线程池没有关闭，就由提交任务的当前线程处理。
- DiscardPolicy，丢弃策略
- DiscardOldestPolicy，丢弃最老任务，如果线程池未关闭，就弹出队列头部的元素

### 线程池的工作流程

1. 当线程数n小于corePoolSize时，创建新的线程执行任务
2. 当线程数n大于corePoolSize且小于maximumPoolSize时：
    - 如果任务队列没满，则任务添加到队列中，等待执行
    - 如果任务队列满，则创建线程执行任务
3. 如果线程数n等于maximumPoolSize时，再有任务到达时，执行拒绝策略

### 线程池参数的配置

一般按照多线程执行任务的类型可以分为`CPU密集型`和`I/O密集型`

**CPU密集型**：

> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，
> 比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。
> 一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。


**IO密集型**：

> 这种任务运行会导致系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，
> 这时就可以将 CPU 交出给其它线程使用。
> 因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

**日常情况**

在日常的应用场景中，通常遇不到这两种极端情况，可以参考一下公式并且通过压力测试不断尝试从而获取到一个最适合的线程数配置：

`线程数 = N(CPU核心数) * (1 + WT(线程等待时间) / ST(线程运行时间)`



### 参考文献

- [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)