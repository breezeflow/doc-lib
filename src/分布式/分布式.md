[[TOC]]
## 架构

### SOA

面向服务的架构，服务之间相互依赖，服务间通过网络调用。

SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。

特点：
1. 大模块业务
2. 通常松耦合
3. 看重中央管理

### 微服务

微服务就是将一个单体架构的应用按业务划分为一个个的独立运行的程序即服务，它们之间通过HTTP协议进行通信。

同SOA类似，但微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，意思就是服务的拆分更加细粒度。

特点：
1. 通过服务实现组件化
2. 根据业务划分服务和开发
3. 去中心化，服务可以有独立的数据源

**拆分原则**

- 先少后多（微服务数量）、先粗后细(粒度)
- 基于业务逻辑进行拆分（用户群体、业务领域等模型DDD）
- 基于可靠性（核心模块独立化、主次链路隔离）
- 基于性能拆分（独立拆分高性能场景）
- 接口需保证幂等
- 接口数据定义严禁内嵌，透传

### 中台

中台的产生并非完全是自顶向下的战略设计，也并非是为了追随某种行业风口，而是随着公司业务高速发展、组织不断膨胀的过程中暴露的种种问题需要被解决

解决的问题：

1. 重复造轮子，业务功能的复用，DevOps 效率问题等
2. 平台化
3. 数据孤岛

中台的三个层面：
1. 业务中台：公共服务，用户服务，物流服务，支付服务，不同的业务场景可能复用
2. 数据中台：大数据时代，数据的收集、数据的处理、分析、统计
3. 技术中台：底层基础服务：安全认证、权限管理、消息通知

## 分布式理论

### 发展历程

现假设有这样一个电商系统，功能包括：用户角色权限、商品展示、下单购买、支付、库存等功能。

<font color="red" size="4px">1.单机模式</font>：所有功能写在一个Project下，发布到一个tomcat。

**但存在这些问题**：
1. 每次发布，系统就不可用，如果项目大发布时间较长的话，对用户来说不太合理。
2. 当用户访问量很大时，一个tomcat、或者一台机器抗不住那么大的压力，服务容易挂掉，机器容易宕机。

针对上述问题，想到的对策是：**加机器**

<font color="red" size="4px">2.集群</font>：将项目发布到多台机器的tomcat上，然后使用nginx进行负载均衡，这样可以缓解访问压力，且可以实现灰度发布，不至于系统一下不可用。

**但依然存在以下问题**：

1. 系统上线进入迭代期后，改动业务代码会较多，那些功能已经成熟的基础模块也要跟着发布，每台机器tomcat多了很多不变的代码。
2. 当业务代码越来越复杂，各个功能模块的逻辑耦合度较高，后续扩展比较麻烦
3. 前后端融合在一块，团队之间开发后要融合在一块，增加了开发人员的难度


<font color="red" size="4px">3.分布式</font>：将系统根据功能模块进行拆分，例如：基础数据、商品购买，下单、支付、库存、售后等服务，然后分别部署到不同机器的tomcat上。

这样做的好处：
1. 每个tomcat上的代码少了，负责的功能单一。
2. 更加灵活的给不同的服务进行处理（根据热点服务和基础服务），或者根据时间、活动期给服务增加集群、容错、降级等分布式处理。减少不必要的资源浪费。
3. 模块与模块间的耦合度低，易扩展，开发人员分工更加明确，更加方便。加上前后端分离，不会因为系统升级或者发布，导致系统无法访问。

**这样做的存在的问题**：
1. 系统架构的搭建，以及等分布式问题常见问题，例如各个节点数据的一致性，事务的控制等，会增加开发难度
2. 由于业务的拆分，集群部署，会导致运维成本变高

<font color="red" size="4px">4. 微服务</font>：微服务同分布式类似，但服务、功能拆分更加精细，明确。所以微服务的各个服务模块很小，数量很多。

**微服务和分布式的异同：**
1. 微服务旨在拆分服务、解耦、服务单一职责，分布式强调分解压力部署到不同机器上。
2. 微服务同样要解决分布式中面临的各种难题。
3. 分布式系统不一定是微服务

### CAP理论

<font color="red" size="4px">CAP</font>： 一致性 `Consistency`，可用性`Availability`，分区容错`Partition tolerance`

#### 一致性
1. 例如mysql主从复制、读写分离架构，主节点负责读写、从节点只负责读、基于binlog、relaylog 实现了主节点数据同步从节点数据的最终一致性
2. 服务间数据存储的一致性，例如，库存和订单数量数据的一致性

#### 可用性
可用性 在集群中每个节点读写必须在第一时间响应，不会受到其他服务的影响。

#### 分区容错性
当分布式系统中节点和节点之间的通信出现了问题，就称分布式系统出现了分区。
分区并不一定是由网络故障引起的，也可能是因为机器故障。

分区容忍性是指，如果出现了分区问题，我们的分布式存储系统还需要继续运行。不能因为出现了分区问题，整个分布式节点全部停止提供服务。

**一致性和可用性之间的矛盾**：
因为网络通信是不可靠的，所以网络容错必须要得到保证。所以，对于分布式系统，当发生分区错误时，我们处理的重点是侧重于一致性还是可用性。所以分布式系统一般分为两种类型：`CP`、`AP`。

CP，当发生分区故障后，例如：如果订单系统，无法访问用户账务系统，就会导致只增加了订单，没有扣除现金，这种情况需要侧重于保证数据的一致性，只能返回失败，舍弃订单服务的可用性。代表：zookeeper

AP，当系统发生分区故障后，例如：分布式内容系统中修改了一个节点的文章内容，此时需要同步到其他节点去，但是发生了网络分区现象，但又不能因为只是修改了内容就导致服务不可用，这种情况应该侧重于保证服务的可用性，如果客户端访问到旧数据的节点，则依旧返回旧数据，等网络恢复后，再继续同步，保证最终一致性。代表：Eureka

AC，严格意义上来说是不存在的，丢弃了P(分区)，意味着分布式CAP定理中的"分布式" 已经抛弃了，例如单点的MySQL，MySQL主从实际上可以理解成多个单点MySQL，通过Binlog数据同步逐渐将数据同步到所有单点上，写主读从，因此依旧是是单点的CA系统，舍弃了P。


### BASE理论

思想：即使无法做到强一致性，但可以采用适当的采取弱一致性，即最终一致性。

<font color="red" size="4px">BASE</font>：
基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

**基本可用**：例如：搜索时间由1s变成2s；降级页面（当访问量较多时，出现某些服务不可用时），或者说5台机器挂了一台，这是至少保证了80%的用户还可以使用。

**软状态**：例如：订单模块和支付模块，即使发生分区现象，通过中间状态，下单成功、未支付、已支付这样的状态，记录异常的订单，网络恢复后再更新数据，实现了保证服务可用前提下的最终一致性。

**最终一致性**：基于MQ的重试机制，得到异步任务处理结果后，保证数据的最终一致性。


### 分布式架构下的高可用

高可用就是：长时间提供服务（99.99%指标）

1. 避免单点故障：
    - 负载均衡（软件负载：nginx）
    - 热备：例如：nginx的双机热备（keep-alived)
2. 应用的高可用：
    - 故障监控、链路监控、日志监控、自动预警
    - 应用的容错、服务降级、限流
    - 数据：数据分库，读写分离


### 分布式架构下的可伸缩设计

<font color="red" size="4px">垂直伸缩</font>：提升硬件能力，加内存，加固态硬盘，高端存储

<font color="red" size="4px">水平伸缩</font>：增加服务器


## 分布式锁

#### 使用场景

1. 多个业务操作共享资源，例如：手动调仓 和 后台定时任务刷新待成交的调仓
2. 分布式系统，多个实例并发访问，就是多个线程访问同一个资源
3. 不同服务之间访问共享变量，例如，退货和付款都要操作库存。

#### 实现方案

1. 基于Redis，现成的解决方案：redisson
2. 基于zookeeper，现成的解决方案：curator
3. 基于数据库，例如MySQL，InnoDB引擎支持行锁

##### 基于Redis实现

1. `SETNX`后无法释放锁，导致死锁
	
	加锁后，如果程序逻辑异常或服务进程挂了，就会导致永远无法释放锁，其他客户端永远获取不到锁，从而导致死锁的情况，解决办法：设置锁失效时间

2. `SETNX`和`EXPIRE`非原子操作

	加锁 和 设置失效时间 两个命令并非是原子操作的，存在加锁后但未成功设置失效时间，依旧会产生死锁的情况，redis2.6.X后，增加了set命令可以加锁的同时设置失效时间，是原子操作，从而解决死锁问题。

##### 基于zookeeper实现

1. 客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。
2. 客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。
3. 客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端获得了锁，在它前面没有别的客户端拿到锁。
4. 如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。

释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可，不过也仍需要考虑删除节点失败等异常情况。

Curator 实现分布式锁，是创建的临时顺序节点（EPHEMERAL_SEQUENTIAL），临时节点的特征保证了锁持有者与ZooKeeper断开时强制释放锁；节点的有序性特性避免了加锁较多时的惊群效应

##### 基于Mysql实现

1. 基于唯一索引实现
	新建一张锁表，lock_key设置为唯一索引，加锁就是insert一条数据，释放锁就是delete一条数据
	优点：实现简单
	缺点：
	- 非阻塞的，获取锁失败后，就结束了，可以手动添加阻塞队列，但实现成本也提高了
	- 性能受限于数据库的性能瓶颈
	- 数据库单点故障，就会导致锁无法释放，可以做成集群，也可以做失败重试等措施，但实现成本也提高了
	- 锁非重入，且是不公平锁，多个线程竞争，全凭运气

2. 基于排它锁实现
	实现方式上同唯一索引类似，只是获取锁的时候，是通过select ... for update 的方式来获取，
	缺点：
	- 排他锁会占用连接，产生连接爆满的问题；
	- 如果表不大，可能并不会使用行锁；
	- 同样存在单点问题、并发量问题。

3. 乐观锁实现
	一般是通过为数据库表添加一个 version 字段来实现读取出数据时，将此版本号一同读出。之后更新时，对此版本号加1，在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。实际就是个CAS过程



## 分布式事务

一次用户请求需要不同的微服务接口共同完成，这些微服务分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些服务接口要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库或者相同数据库不同表的数据一致性。

### 产生的原因

**场景1**
一个service产生多个节点，例如， 一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护。这样不能保证扣完积分后，优惠券一定能扣减成功

**场景2**
一个resource多个节点，例如，对于一个转账业务来说，你给朋友转钱，可能你的数据库是在北京，而你朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。

### 2PC

**XA规范**：是一个事务管理协议，规定了
1. TransactionManager: 全局事务管理器，管理多个数据源
2. XAResource: 针对不同数据源封装的一个接口
3. 两阶段提交：多数据源的事务管理机制
	- 第一阶段：不同数据源执行完之后会将结果先提交给全局事务管理器
	- 第二阶段：由全局事务管理器根据所有数据源的提交结果来决定最终提交还是回滚

**特点**：强一致性，两阶段提交，事务太长，业务吞吐量低

**适用场景**：处理同一个服务中，使用了多个数据源的数据一致性问题，所以，不适合微服务，微服务系统中数据源分散在不同的服务中。

**具体实现**：基于Atomikos实现JTA（Java Transaction Manager Java事务管理器）分布式事务，而JTA是基于XA规范的Java实现

1. 添加依赖
```
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-jta-atomikos</artifactId>
</dependency>
```
2. 数据源配置 区别点：注意使用基于 XADataSource接口的数据源(druid 也有对应的实现)，并用Atomikos的数据源AtomikosDataSourceBean来包装
```
@Bean("firstDataSource")
public DataSource firstDataSource(){
MysqlXADataSource mysqlXADataSource = new MysqlXADataSource();
mysqlXADataSource.setUrl(jtaFirstDatasourceProperties.getXaPropertiesUrl());
mysqlXADataSource.setUser(jtaFirstDatasourceProperties.getXaPropertiesUser());
mysqlXADataSource.setPassword(jtaFirstDatasourceProperties.getXaPropertiesPassword());

AtomikosDataSourceBean xaDataSource = new AtomikosDataSourceBean();
xaDataSource.setXaDataSource(mysqlXADataSource);
xaDataSource.setUniqueResourceName(jtaFirstDatasourceProperties.getUniqueResourceName());
xaDataSource.setMinPoolSize(10);
xaDataSource.setPoolSize(50);
xaDataSource.setMaxPoolSize(50);
return xaDataSource;
}
```
3. 多个数据源的配置中，可以不添加transactionManager的配置，会使用atomikos的默认的全局事务管理器，源码：`AtomikosJtaConfiguration.java` 业务中直接使用@Transactional注解即可
```java
@Transactional
public void test(String orderNo){
        
   // 下单
   Order order = new Order();
   order.setUserId(userId);
   order.setOrderNo(orderNo);
   order.setGoodsId(goodsId);
   order.setGoodsNum(num);
   order.setGoodsPrice(price);

   //第一个数据源
   firstDataSourceServicie.createOrder(order);
   firstDataSourceServicie.payment(order);

   //第二个数据源
   secondDataSourceService.reduceGoods(order);
}
```
### TCC

- Try阶段：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性）
- Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。
- Cancel阶段：取消执行，释放Try阶段预留的业务资源，Cancel操作满足幂等性，Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

**特点**：基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高

**适用场景**：强隔离性、严格一致性要求的业务，执行时间较短的业务

### 本地消息表

当服务A 调用 服务B 发生数据库数据更新操作时，首先会更服务A相关业务表的数据，同时服务A中新增一张消息表，消息表中插入一条业务处理对应的消息数据，可以添加状态为发送中，两个操作发生在同一个事务中，保证要么都执行，要么都不执行，对于服务B的操作通常对用户来说是透明的，例如用户支付完，不需要立刻知道后续的操作，只需要我支付成功了，所以会发送一条消息到服务MQ，服务B监听并消费消息，进行后续业务的处理，处理成功后，发送一条ACK消息到MQ，同时服务A也监听并消费，更新消息表中的状态为已完成。

![本地事务表](~@img/distribute/local_transaction_table.jpg)

**存在的问题**

1. 服务A的业务消息因为网络原因，没有成功发送到MQ，导致消息丢失怎么办？
2. MQ接受到消息后，由于消息中间件内部原因导致消息丢失怎么办？
3. 服务B的消费者因为网络原因，没有接受到消息，或者消费过程中出现异常，导致消息丢失怎么办？

<font color="red">以上情况都是：消息的可靠性投递问题</font>

本地消息表中记录的消息，同要发送到MQ的消息是一致的，可靠性投递的解决方案就是重复投递，需要消费者的消费接口是幂等的，服务A需要新增定时任务，定时将发送中的消息重新投递到业务MQ中进行重新消费，如果已经消费过了，则不再处理消费逻辑，直接返回ACK消息，服务A更新状态为已发送。**重新投递也存在失败的可能，可以设置最大失败次数，若达到最大失败次数，则记录日志、发送通知、短信或者告警，然后通知人工处理**

**优点**
1. 实现成本相对较低
2. 基于软状态及可靠性投递方案实现了分布式事务的最终一致性

**缺点**
1. 本地消息表与业务耦合在一起，难于做成通用的
2. 本地消息表也是基于数据库实现的，基于数据库的磁盘IO性能，高并发下依然存在性能瓶颈

[本地消息表](https://juejin.cn/post/6844904041659498509)

### RocketMQ

RocketMQ提供了事务消息的功能，采用2PC(两段式协议) + 补偿机制（事务回查）来实现分布式事务的最终一致。

**半事务消息**
发送方已经成功地将消息发送到了消息队列 RocketMQ 版服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息。

**消息回查**
由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，消息队列 RocketMQ 版服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该询问过程即消息回查。

![RocketMQ事务](~@img/distribute/RocketMQ_Transaction.jpg)

**事务消息发送步骤**：
1. 发送方将消息发送至消息队列 RocketMQ 版服务端。
2. 消息队列 RocketMQ 版服务端将消息持久化成功之后，向发送方返回 Ack 确认消息已经发送成功，此时消息为`半事务消息`。
3. 发送方开始执行本地事务逻辑。
4. 发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback）
	- 服务端收到 Commit 状态则将半事务消息标记为可投递，订阅方最终将收到该消息；
	- 服务端收到 Rollback 状态则删除半事务消息，订阅方将不会接受该消息。

**事务消息回查步骤**：
1. 在断网或者是应用重启的特殊情况下，上述发送步骤 4 提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。
2. 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
3. 发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照发送步骤 4 对半事务消息进行操作。

总体而言RocketMQ事务消息分为两条主线：
1. 发送流程：发送half message(半消息)，执行本地事务，发送事务执行结果
2. 定时任务回查流程：MQ定时任务扫描半消息，回查本地事务，发送事务执行结果

[RocketMQ事务消息](https://cloud.tencent.com/developer/article/1648617)

### Saga事务

Saga是一个长活事务可被分解成可以交错运行的子事务集合。Saga由一系列sub-transaction Ti组成。每个Ti都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果。这里可以理解为，针对每一个分布式事务的每个执行操作或者是步骤都是一个 Ti，例如扣减库存是T1、创建订单是T2、支付服务是T3。那么针对每个Ti都对应一个补偿动作Ci，例如回复库存C1、订单回滚C2、支付回滚C3。

**Saga事务有两种恢复策略**：

**向前恢复**：

对于执行不通过的事务，会尝试重试事务。事务按照执行顺序执行，例如T1  T2  T3，哪一个步骤失败了，就重试那个步骤，这里有一个假设就是每个子事务最终都会成功。这种方式适用于必须要成功的场景。

**向后恢复**：

在执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式（回滚的方式）。子事务按顺序执行，在执行到事务T3的时候，该事务执行失败了，一次执行补偿动作 C3 C2 C1，也就是回滚整个Saga的执行结果。

**Saga子事务执行顺序的编排有两种策略**：

**编排**

子事务之间的调用、分配、决策和排序，通过消息机制进行沟通，通过监听器的方式监听其他参与者发出的消息，从而执行后续的逻辑处理。没有中间协调点，是一种去中心化的模式。

![Saga编排模式](~@img/distribute/saga2.png)


**控制**

Saga提供一个控制类，事务执行的命令从控制类发起，按照逻辑顺序请求子事务，从子事务那里接受到反馈以后，控制类向其他子事务发起调用。所有Saga的子事务都围绕这个控制类进行沟通和协调工作。

![Saga控制模式](~@img/distribute/saga1.png)

**总结**

Saga是针对分布式长活事务的解决方案，针对事务长、多、复杂的情况，特别是服务由多个公司开发具有不可控性，可以使用Saga模式进行分布式事务的处理。Saga在处理事务一致性方面采取了向前恢复和向后恢复策略，前者通过不断重试的方式保证事务完成，而后者通过子事务的补偿事务，逐一回滚的方式让事务标记失败。在分布式协调方面，Saga采用了两种模式：编排和控制。前者让参与者（服务）之间通过消息进行沟通，根据事件出发事务的执行流程，是一种去中心化的模式。后者通过中心控制类，处理事务的执行和回滚步骤，统一调用服务和接受服务的反馈。

### Seata

[Seata](https://seata.io/zh-cn/docs/overview/what-is-seata.html)是一款开源的分布式事务解决方案，提供了 AT、TCC、SAGA 和 XA 事务模式

**AT模式**

 基于本地关系型数据库 的ACID 事务，通过两阶段提交协议的方式实现。

一阶段：业务数据和回滚日志记录在同一个本地事务中提交（undo log 表），释放本地锁和连接资源。

二阶段：

- 提交：快速提交，异步删除对应undo log日志
- 回滚：通过XID及比对undo log 数据及记录的SQL相关进行事务补偿

**TCC模式**

全局事务由若干个分支事务组成，分支事务要满足两阶段提交的模型
1. 一阶段 自定义prepare 逻辑
2. 二阶段 自定义commit 或 rollback 逻辑 

## 分布式协议





## 参考文档

- 美团技术-领域驱动设计：[https://tech.meituan.com/2017/12/22/ddd-in-practice.html](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)