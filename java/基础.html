<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DocLib</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/doc-lib/logo.png">
    <meta name="description" content="">
    <meta name="robots" content="all">
    <meta name="author" content="andy">
    <meta name="keywords" content="">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/doc-lib/assets/css/0.styles.4843f0ae.css" as="style"><link rel="preload" href="/doc-lib/assets/js/app.e0f2fd26.js" as="script"><link rel="preload" href="/doc-lib/assets/js/2.6b803bbe.js" as="script"><link rel="preload" href="/doc-lib/assets/js/8.dd3e4356.js" as="script"><link rel="prefetch" href="/doc-lib/assets/js/10.bde0c68f.js"><link rel="prefetch" href="/doc-lib/assets/js/11.a0e3af8e.js"><link rel="prefetch" href="/doc-lib/assets/js/12.980ee308.js"><link rel="prefetch" href="/doc-lib/assets/js/13.74ba3036.js"><link rel="prefetch" href="/doc-lib/assets/js/14.9f5758c6.js"><link rel="prefetch" href="/doc-lib/assets/js/15.05ab78d2.js"><link rel="prefetch" href="/doc-lib/assets/js/3.2b71297b.js"><link rel="prefetch" href="/doc-lib/assets/js/4.d720f5fc.js"><link rel="prefetch" href="/doc-lib/assets/js/5.e0a3531b.js"><link rel="prefetch" href="/doc-lib/assets/js/6.96969d71.js"><link rel="prefetch" href="/doc-lib/assets/js/7.844b8854.js"><link rel="prefetch" href="/doc-lib/assets/js/9.bb38e566.js">
    <link rel="stylesheet" href="/doc-lib/assets/css/0.styles.4843f0ae.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/doc-lib/" class="home-link router-link-active"><!----> <span class="site-name">DocLib</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/doc-lib/menu.html" class="nav-link">
  目录
</a></div> <a href="https://github.com/breezeflow/doc-lib" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/doc-lib/menu.html" class="nav-link">
  目录
</a></div> <a href="https://github.com/breezeflow/doc-lib" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#异常" class="sidebar-link">异常</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#集合" class="sidebar-link">集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#集合分类" class="sidebar-link">集合分类</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#hashmap" class="sidebar-link">HashMap</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#concurrenthashmap" class="sidebar-link">ConcurrentHashMap</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#treemap" class="sidebar-link">TreeMap</a></li></ul></li><li><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#关键字" class="sidebar-link">关键字</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#synchronized" class="sidebar-link">Synchronized</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#volatile" class="sidebar-link">volatile</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#threadlocal" class="sidebar-link">ThreadLocal</a></li></ul></li><li><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#juc" class="sidebar-link">JUC</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#锁" class="sidebar-link">锁</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#atomic" class="sidebar-link">Atomic</a></li><li class="sidebar-sub-header"><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#blockingqueue" class="sidebar-link">BlockingQueue</a></li></ul></li><li><a href="/doc-lib/java/%E5%9F%BA%E7%A1%80.html#参考文献" class="sidebar-link">参考文献</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul></ul></div><p></p> <h2 id="异常">异常</h2> <p><img src="/doc-lib/assets/img/throwable.e93ae334.jpg" alt="异常类"></p> <p>Throwable是java语言中所有错误和异常的超类。它有两个子类：Error、Exception。</p> <p><code>Error(错误)</code>：Error类及其子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。程序员应该关注Exception为父类的分支下的各种异常类。
<code>Exception(异常)</code>：Exception及其子类，代表程序运行时的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p> <p>异常又通常被分为两类：<code>非检查异常(Unchecked Exception)</code>、<code>检查异常(Checked Exception)</code></p> <p><code>Unchecked Exception</code>：编译时不会提示和发生异常，运行时一般会报错，例如：<code>NullPointerException</code>、<code>ArithmeticException</code>、<code>IndexOutOfBoundsException</code>等</p> <p><code>Checked Exception</code>：编译时就会提示异常，程序要求强制通过try...catch或者throws处理否则编译不通过，例如：<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundExceptioon</code>等</p> <h2 id="集合">集合</h2> <h3 id="集合分类">集合分类</h3> <ol><li>线程不安全的集合<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>TreeMap</code>、<code>HashSet</code>、<code>TreeSet</code>。<code>HashSet</code>: 基于HashMap实现，值作为HashMap的key存储的所以是不重复、无序的</li> <li>线程安全的集合: <code>HashTable</code>、<code>Vector</code></li> <li>高性能的线程安全集合
<code>ConcurrentHashMap</code>: jdk1.7基于分段锁实现，将数组分割多段，每段添加一个锁，所线程访问不同数据段的数据就不会出现锁竞争。jdk1.8采用CAS+Synchronize来保证线程安全，Synchronized只锁链表和红黑树的首节点，只要hash不冲突就不会产生并发，从而提升效率
<code>ConcurrentSkipListMap</code>: 基于链表实现，线程安全的有序的map，相当于线程安全的TreeMap
<code>ConcurrentSkipListSet</code>: 线程安全的有序集合，相当于线程安全的TreeSet
<code>CopyOnWriteArrayList</code>: 线程安全的List，读写分离的思想，写数据前先copy一份（加锁），然后再新增，此时读还是基于原有的数组，新增完之后再移动指针，适用于读多写少，实时性要求不高的场景
<code>CopyOnWriteArraySet</code>: 基于CopyOnWriteArrayList实现</li></ol> <h3 id="hashmap">HashMap</h3> <p>HashMap用来存储键值对类型的数据，基于哈希表来存储，在JDK1.8中的就是一个Node[]</p> <p><strong>存储数据</strong></p> <p><code>map.put(&quot;key&quot;,&quot;value&quot;)</code></p> <ol><li>根据key的hashCode方法得到hashCode值</li> <li>根据Hash算法的后两部运算（高位运算和取模运算）确定键值对的存储在数组的位置</li> <li>如果同时存在两个key计算得到相同的位置，说明hash冲突了</li></ol> <p><strong>哈希表解决Hash冲突的方法</strong></p> <ol><li>开放地址发</li></ol> <ul><li>线性探测法：遇到冲突，判断下一位是否为空</li> <li>平方探查法：遇到冲突，查找当前索引平方后位置是否为空</li> <li>双哈希法：有多个hash函数，当发生冲突时，使用第二个，第三个，直到无冲突</li></ul> <ol start="2"><li>链地址法：采用链表的结构，每个hash表的节点都有一个next指针，发生冲突时，插入到这个单向链表</li></ol> <blockquote><p>hash算法计算的结果越分散，hash碰撞概率越小，map存取效率越高
hash表数组越大，即hash桶数组越大，计算结果也会越分散，hash碰撞概率也会越小
通过扩容机制+Hash算法，即可满足节省内存也可以尽量减少hash碰撞的概率</p></blockquote> <p>HashMap默认长度16，默认负载因子(Load Factor)0.75，threadHold = length * LoadFactor，当hash桶的使用率超过这个个数时需要扩容为原来两倍</p> <blockquote><p>hash桶的大小设置成2^n是为了在取模和扩容时做优化，同时为了减少冲突（HashMap定位哈希桶索引位置的时候也加入了高位参与运算）</p></blockquote> <p><strong>JDK1.8与JDK1.7的对比</strong></p> <ol><li><strong>数据结构</strong>：1.7是<code>数组+单链表</code>，1.8变成<code>数组+单链表+红黑树</code>，当链表长度增加时，插入和查询的效率都会降低，链表长度超过8时转换成红黑树，小于6时退化成链表，引入红黑树可以提高查询效率，红黑树一种特殊的平衡二叉树，通过着色、自旋等特性能使得查询、插入和删除时间复杂度控制在O(log N)</li> <li><strong>扩容优化</strong>：1.7扩容后需要重新计算每个桶的位置，1.8之后无需重新计算新的位置，要么不变，要么变成原位置+oldCap，扩容之所变成原来两倍</li> <li><strong>链表节点的插入方式</strong>：之前是头插法，1.8后变成了尾插法，因为在并发操作下，头插法会出现环形链表的情况，但这并不是说1.8之后hashmap就是线程安全的，只是针对1.7做了优化，并发情况下还会出现其他的问题，例如数据覆盖</li> <li><strong>hash函数的优化</strong>：Java1.8的hash()中，将hash值高位（前16位）参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率</li></ol> <h3 id="concurrenthashmap">ConcurrentHashMap</h3> <p>HashTable是线程安全的Map，不允许null键值对，安全的机制是对put等方法添加synchronized关键字，相当于对整个对象加锁，锁住了整个hash表，所以效率低下，已经被废弃。取而代之的是ConcurrentHashMap。</p> <p>JDK1.7中ConcurrentHashMap采用分段锁的机制保证线程安全。具体来说，将Hash表分为多个分段Segment，每个Segment通过继承ReentrantLock来加锁，这样就保证了每个Segment的线程安全同时也提高的并发的性能。</p> <p>JDK1.8中ConcurrentHashMap采用与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现</p> <h3 id="treemap">TreeMap</h3> <p>有序的Map，基于红黑树实现，实现了<code>NavigableMap</code>-&gt;<code>SortedMap</code></p> <h2 id="关键字">关键字</h2> <h3 id="synchronized">Synchronized</h3> <p>synchronized是基于JVM实现的，非公平的、可重入的重量级锁</p> <p><strong>基本使用</strong></p> <ol><li>修饰普通方法、修饰代码块指定this，对象锁，表示锁住当前对象（this），也可以自己指定锁住对象</li> <li>修饰静态方法、修饰代码块指定class，类锁，表示锁住整个类，同时只能有一个线程访问该类</li></ol> <p><strong>加锁和释放锁的原理</strong></p> <p>底层是通过指令<code>monitorenter</code>和<code>monitorexit</code>以及<code>monitor计数器</code>实现。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得。</p> <ul><li>当执行<code>monitorenter</code>加锁指令时：
<ul><li>如果<code>monitor计数器</code>为0，则表示尚未获取，则该线程会立刻获取到锁，并且将锁计数器+1</li> <li>如果当前对象已经持有了该锁，又重入了该锁，则将锁计数器+1</li> <li>如果该锁被其他线程持有，则阻塞等待锁被释放</li></ul></li> <li>当执行<code>monitorexit</code>释放锁指令时：将锁计数器-1，如果减完不为0表示刚才是重入的，仍然持有该锁；如果减完为0，表示不再持有该锁</li></ul> <blockquote><p>synchronized先天具有重入性。就是基于锁计数器实现的，每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一</p></blockquote> <p><strong>Synchronized优化</strong></p> <p>JDK1.6之前，synchronized性能表现不佳，JDK1.6对其进行了一些列的优化，锁粗化、锁消除、以及引入偏向锁、轻量级锁、适应性自旋锁等减少锁的开销，优化的核心理念是：<strong>根据当前的并发度尽可能的避免直接用OS(操作系统)的互斥量（Mutex Lock）完成同步操作</strong></p> <p><strong>锁粗化</strong></p> <p>如果发现有代码⾥连续多次加锁释放锁的代码，会给合并为⼀个锁，就是锁粗化，避免频繁多次加锁释放锁</p> <p><strong>锁消除</strong></p> <p>在编译的时候，JIT编译器会通过逃逸分析技术，来分析synchronized锁对象，是不是只可能被⼀个线程来加锁，没有其他的线程来竞争加锁，这个时候编译就不⽤加⼊monitorenter和monitorexit的指令
就可以消除这个锁了，提升这段代码的执⾏的效率，例如在方法里面对一段代码加对象锁，但代码里的常量不会直接返回，也就不会出现逃逸，线程绝对安全，也就不需要加锁。</p> <p>JDK1.6，synchronized同步锁有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级锁</code>、<code>重量级锁</code>，会随着竞争情况（并发度）逐渐升级。锁可以升级但是不可以降级。</p> <blockquote><p>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</p></blockquote> <p><strong>无锁</strong></p> <p>不锁住资源，多个线程中只有一个能修改成功，其他线程会重试直到修改成功。CAS就是无锁的一种实现</p> <p><strong>偏向锁</strong></p> <p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</p> <p>当一个线程访问同步代码块并获取锁时，会在Mark Word（基于Hotspot虚拟机）里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。</p> <p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁</p> <p>JDK 6及之后版本中是默认启用的。可通过JVM参数关闭：<code>-XX:UseBiasedLocking=false</code>，关闭之后程序默认会进入轻量级锁状态</p> <p><strong>轻量级锁</strong></p> <p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p> <p><strong>重量级锁</strong></p> <p>当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p> <blockquote><p>综上，<code>偏向锁</code>通过对比Mark Word解决加锁问题，避免执行CAS操作。而<code>轻量级锁</code>是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。<code>重量级锁</code>是将除了拥有锁的线程以外的线程都阻塞。</p></blockquote> <h3 id="volatile">volatile</h3> <p><strong>防止指令重排序</strong></p> <p>案例：双重校验锁的单例模式，实例化对象分为三步：<code>分配内存空间</code>、<code>初始化对象</code>、<code>将内存空间地址复制给对应的引用</code>，由于存在指令重排的存在，可能发生分配内存空间之后，就将地址复制给引用了，导致返回的对象尚未初始化完成。</p> <p><strong>实现可见性</strong></p> <p>基于Java内存模型，每个线程中拥有一个缓存区（线程工作内存），一个线程加载了物理内存中的共享变量到缓存区进行了更改，另一个线程是看不到的，如果其他线程同样做这样的操作，然后两个线程先后刷新更改到物理内存中，就会出现一个线程的更新丢失的情况，volatile就是解决这个问题的</p> <h3 id="threadlocal">ThreadLocal</h3> <p><code>ThreadLocal</code>是一个在多线程中为每一个线程创建单独的变量副本的类，避免多线程操作共享变量导致数据不一致的情况。</p> <p><strong>基本原理</strong></p> <div class="language-Java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// ThreadLocal set方法</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token comment">// ThreadLocal get方法</span>
<span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">return</span> result<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>每个Thread都会有一个<code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</code>的引用，用来存储当前线程周期内所需要存储的数据，其他线程无法获取，在当前线程中，我们创建ThreadLocal并来存储数据时，会先判断当前线程中是否有一个这样全局唯一的ThreadLocalMap，不存在则创建，存在则直接存储数据，key为我们创建的ThreadLocal，value是需要存储的值。同一个线程中可以有多个ThreadLocal。所以用Map存储，每个ThreadLocal对象都是唯一的，都有一个唯一标识的threadLocalHashCode，这个hashCode是一个static的AtomicInteger类型，每次加一也是原子性的，所以保证了ThreadLocal对象的唯一性，所以用ThreadLocal作为Map的key。ThreadLocal只是作为一个访问线程内部的ThreadLocalMap的入口。</p> <p><strong>ThreadLocal内存泄漏问题</strong></p> <p>ThreadLocalMap的key是一个弱引用，这意味着，如果我们使用ThradLocal对象时，没有了强引用，则GC就会回收该对象，就导致了ThreadLocalMap内Entry的key就变成null，但是enrty本身还是有一个强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，如果线程迟迟没有死亡，那么永远无法回收，造成内存泄漏。</p> <p>所以官方推荐将ThreadLocal定义为static全局唯一，避免丢失ThreadLocal强引用，就能保证随时remove掉entry内的key与value。</p> <p><code>InheritableThreadLocal</code>可以实现父子线程间数据传递</p> <p><code>TransmittableThreadLocal</code>跨线程池的场景下，线程间数据的传递</p> <h2 id="juc">JUC</h2> <h3 id="锁">锁</h3> <p>JUC中的锁包含三个重要的实现：ReentrantLock、ReentrantReadWriteLock、StampedLock</p> <p><strong>AQS</strong>：队列同步器，是构建锁及其他同步组件的基础，AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0时表示已经获取了锁，当state = 0时表示释放了锁。AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// AQS提供的获取独占式锁的模板方法，该方法对中断不响应，对线程进行中断操作后，该线程会依然位于CLH同步队列中等待着获取同步状态</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// tryAcquire 尝试获取锁，成功为true，失败为false</span>
				<span class="token comment">// 如果失败，则调用addWaiter加入CLH同步队列尾部</span>
				<span class="token comment">// acquireQueued：当前线程会进行自选阻塞等待,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过，如果有，则自我中断，否则结束方法调用</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">EXCLUSIVE</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			 <span class="token comment">// 整个过程是否失败的标识，便于finally执行取消获取锁</span>
        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
        		<span class="token comment">// 中断标识</span>
            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// 自旋尝试获取锁，直到成功为止</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// shouldParkAfterFailedAcquire 检查并更新获取锁失败的节点的状态。如果线程应该阻塞（锁已经被其他线程占用时，当前线程应该被阻塞），则返回true。</span>
                <span class="token comment">// parkAndCheckInterrupt 通过LockSupport.park 阻塞当前线程，并返回当前线程是否被中断过，决定后续是否自我中断</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><strong>CLH同步队列</strong>
AQS中维护的FIFO双向队列就是CLH同步队列，在CLH同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next）</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//CLH入队方法，双向链表入队，设置前驱节点和，前驱节点和后置节点即可</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">// 基于当前线程的基本信息，构建一个Node</span>
        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
            <span class="token comment">// 通过一次CAS操作，尝试快速加入双向链表尾部</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token comment">// 成功就返回</span>
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 否则，enq方法中进行循环CAS尝试加入链表尾部</span>
        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>StampedLock</strong></p> <p>StampedLock和ReadWriteLock相比，改进之处在于：提供了乐观读锁的相关方法， 读的过程中也允许获取写锁后写入，如果获取乐观读锁后，发现有写锁获取过，则怀疑数据已经被窜改，会升级成悲观读锁.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//乐观读锁案例</span>
<span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
       <span class="token comment">//sl(StampedLock)获得一个乐观读锁</span>
        <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">double</span> currentX <span class="token operator">=</span> x<span class="token punctuation">,</span> currentY <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">//将两个字段读入本地局部变量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span>
                stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 验证失败，有写锁发生，获得一个悲观读锁</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    currentX <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 重新读入本地局部变量</span>
                    currentY <span class="token operator">=</span> y<span class="token punctuation">;</span> 
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放悲观读锁</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>currentX <span class="token operator">*</span> currentX <span class="token operator">+</span> currentY <span class="token operator">*</span> currentY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="atomic">Atomic</h3> <p>底层是基于Unsafe类的本地方法<code>compareAndSwapInt</code>实现的，意思是比较后交换，如果当前值==预期值，原子化地将该值设置为给定的更新值。</p> <h3 id="blockingqueue">BlockingQueue</h3> <ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li> <li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li> <li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li> <li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li> <li>SynchronousQueue：一个不存储元素的阻塞队列。</li> <li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li> <li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul> <h2 id="参考文献">参考文献</h2> <ul><li>美团技术-HashMap：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2016/06/24/java-hashmap.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>美团技术-Java的锁：https://tech.meituan.com/2018/11/15/java-lock.html</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/doc-lib/assets/js/app.e0f2fd26.js" defer></script><script src="/doc-lib/assets/js/2.6b803bbe.js" defer></script><script src="/doc-lib/assets/js/8.dd3e4356.js" defer></script>
  </body>
</html>
